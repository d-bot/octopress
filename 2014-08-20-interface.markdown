---
layout: post
title: "Interface"
date: 2014-08-20 05:03:08 +0000
comments: true
categories:
#published: false
---

어플리케이션은 클래스로 구성되어 있지만 메시지를 통해 정의된다. 어플리케이션의 움직임을 반영하는 것은 메시지이며 이 메시지가 에플리케이션을 살아 움직이게 한다. 그래서 디자인은 객체 사이를 가로지르는 메시지에 관심을 두어야 한다.

## Flexible Interface

인터페이스는 메시지의 묶음으로 표현되고 메시지들 자체가 인터페이스를 정의한다. 즉, 인터페이스에는 2가지 종류가 있는데 하나는 다른 객체들에 의해 사용되는 public methods 들이고 다른 하나는 public methods 들에 의해 사용되는 private methods 들이다.

식당을 예로 들면 메뉴가 interface 에 속하고 주방에서 일하는 주방장들과 직원들은 private methods 들에 속하며 해당 interface 들이 주고 받는 "메세지" 들은 손님들이 알수 없고 알 필요도 없다.

## 어플리케이션 디자인

자전거 투어 회사 서비스

일단 Trip, Customer, Route, Bike, Mechanic 등의 명확한 물리적이고 behavior + data 를 가지는 명확한 객체들이 먼저 생각난다.

하지만 이들간에 주고 받는 메세지를 자세히 살펴보면서 명확하지 않은 객체들을 발견해 나가는게 중요하다. 즉, class-based design 에서 message-based design 으로 진행하는게 더욱 효과적이다.

즉, 객체들이 주고받는 메시지에 주목해 나가면서 새로운 객체를 발견해 나간다. 이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야하지? 가 아니라 "메시지를 전송해야하는데 누구에게 전송해야 하지?" 라고 질문해야한다. 객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 때문에 객체를 갖게 된 것이다.

### How vs What

메시지를 전송할때 해당 객체가 정확히 무엇(what)을 해야하는지 하나 하나 세세한 작업을 다 알게 되면 해당 작업들이 변경될때마다 메세지를 보내는(sender) 클래스도 변경되어야 한다. 그러므로 What 보다는 How 라는 관점으로 접근해서 어떻게(How) 큰그림안에서 메시지를 보내서 세세한 작업들이 모두 이루어 지도록 메시지를 보내는것이 중요하다.

### Context Independence (easier to test and re-use: 주어진 맥락에서 독립적일 수 있게 하기)

객체가 필요로 하는 맥락(context)는 객체의 재사용성에 바로 영향을 미친다. 단순한 맥락속에 위치한 객체는 사용하기 쉽고 테스트하기도 쉽다. 이런 객체는 자신을 둘러싼 환경에 기대하는 바가 적다. 복잡한 맥락 속에 위치한 객체는 사용하기도 어렵고 테스트하기도 어렵다. 가능한 최고의 상황은 "객체가 자신의 맥락으로부터 완전히 독립되어 있는 것이다. 다른 객체가 누구인지, 그들이 무엇을 하는지를 전혀 모른 채로 협업할 수 있는 객체는 기대하지 않았던 방식으로 참신하게 재사용될 수 있다.

```
       a                 a                           a                         a
      TRIP            Mechanic                      TRIP                    Mechanic
       |                 |                           |                        |
       |---|             |                           |                        |
       | bicycles        |                           |   Prepare_trip(self)   |
       |<--|             |                           |----------------------->--
       |                 |                           |                        ||
       |                 |                           |                        ||
|for each bicycle|       |                           |       bicycles         ||
       |                 |         ========>         --<------------------------
       | prepare bycycle |         == TO ==>         ||                       |
       |---------------->||        ========>         ||                       |
       | clean_bicycle   ||--|                       ------------------------>--
       |                 ||  |                       |                        ||
       |                 ||  |                       |                |for each bicycle|
       |                 ||<--                       |                        ||
       |                etc..                        |                        ||
       |                 ||                          |                        || prepare_bicycle(bike)
       |                 ||                          |                        ||
       |                 ||                          |                        ||
       |<----------------||                          <--------------------------
       a                 a                           a                         a
      TRIP            Mechanic                     TRIP                    Mechanic

```
위의 예제에서 Mechanic 은 어떻게 여행을 준비하는지에 대한 지식은 Mechanic 속에 고립되었고 Trip 이 속한 맥락은 줄어 들었다. Trip 과 Mechanic 모두 수정하기도, 테스트하기도, 다시 사용하기도 쉬워졌다.

Trip 은 Mechanic 의 public interface 에 대해서 아는게 없지만 self 를 argument 로 넘기면서 원하는걸 해달라고 말하면 Mechanic 은 즉시 Trip 을 호출하여 자전거 리스트를 받아내서 자전거를 준비시킨다.

그리고 각 클래스가 교차하는 지점에서 어울리는 여행을 찾아 줄 객체가 필요하다. 아직 정의되지 않은 새로운 객체가 필요하다는 인식은 여러 경로를 통해 얻을 수 있고 그렇게 발견한 클래스는 TripFinder
