---
layout: post
title: "Git Basic"
date: 2015-08-28 08:53:18 +0000
comments: true
categories: Git
---

http://learnbranch.urigit.com
https://rogerdudler.github.io/git-guide/index.ko.html
http://backlogtool.com/git-guide/kr/stepup/stepup1_2.html

### Branch

깃의 브랜치는 특정 커밋에 대한 참조(reference)에 지나지 않음. 브랜치와 커밋을 같이 쓸 때, 어떻게 두 기능이 조화를 이루는지 확인. 일단은 단순히 브랜치를 "하나의 커밋과 그 부모 커밋들을 포함하는 작업 내역" 이라고 기억.

master repo가 가장 최신 커밋(c1)을 가르키고 있는 상태에서 브랜치를 생성하면(git branch bugfix; git checkout bugfix) 생성된 브랜치도 c1 을 가르키게되는데 여기서 새로운 커밋(c2) 을 추가하면 브랜치는 최신 커밋(c2)을 가르킨다.
```ruby
C0
C1 <-- master
C2 <-- bugfix*
```

### Merge

깃의 합치기(merge)는 두 개의 부모(parent)를 가르키는 특별한 커밋을 만들어 낸다. 두개의 부모가 있는 커밋이라는 것은 "한 부모의 모든 작업내역과 나머지 부모의 모든 작업, 그리고 그 두 부모의 모든 부모들의 작업내역을 포함한다"는 의미.

아래와같이 각 브랜치별로 c1 을 부모로 하는 독립된 커밋이 하나씩 있음. 즉, 현재 레파지토리에 지금까지 작업한 내역이 각 브랜치에 나뉘어 담겨 있다는 의미이고 이때 merge 를 사용한다.
```ruby
      c0

      ^
      |

      c1
      ^
      |
  -----------
  ^         ^
  |         |
  c2        c3
bugFix     master*

```

`git merge bugFix master` 하면 아래와 같이 c4 라는 새로운 커밋을 master 가 두 부모가 있는 커밋을 가리키게 된다.

```ruby
      c0

      ^
      |

      c1
      ^
      |
  -----------
  ^         ^
  |         |
  c2        c3
bugFix      ^
  ^         |
  |         |
  |--- c4 --|
     master*

```

이제 master 브랜치에 bugFix를 합친다. `git merge master bugFix`

```ruby
      c0

      ^
      |

      c1
      ^
      |
  -----------
  ^         ^
  |         |
  c2        c3
  ^         ^
  |         |
  |         |
  |--- c4 --|
     master*
     bugFix

```

bugFix가 master 의 부모쪽에 있었기 때문에, git이 별다른 일을 할 필요가 없었음. 간단히 bugFix를 master가 붙어 있는 커밋으로 이동시켰을 뿐, 이제 두 브랜치가 모두 레파지토리의 모든 작업 내역을 포함하고 있음.


### Rebase

브랜치끼리의 작업을 접목하는 두번째 방법은 리베이스. 리베이스는 기본적으로 커밋들을 모아서 복사한 뒤, 다른 곳에 떨궈 놓는 것임. 조금 어렵게 느껴질 수 있지만, 리베이스를 하면 커밋들의 흐름을 보기 좋게 한 줄로 만들 수 있다는 장점이 있음. 리베이스를 쓰면 저장소의 커밋 로그와 이력이 한결 깨끗해진다.


아까 위의 최초 예제에서 bugFix 브랜치를 선택한 상태에서 bugFix 브랜치에서의 작업을 master 브랜치 위로 직접 옮겨 놓으려고 한다. 그렇게 하면, 실제로는 두 기능을 따로따로 개발했지만, 마치 순서대로 개발한 것처럼 보이게 된다.
```ruby
      c0

      ^
      |

      c1
      ^
      |
  -----------
  ^         ^
  |         |
  c2        c3
 master    bugFix*

```
`git rebase master`

```ruby
      c0

      ^
      |

      c1
      ^
      |
  ----|
  ^
  |
  c2
 master
  ^
  |
  c3'
 bugFix*

```

이제 bugFix 브랜치의 작업 내용이 master 의 바로 위에 깔끔한 한 줄의 커밋으로 보이게 됐음. c3 커밋은 어딘가에 아직 남아있고, c3' 는 master 위에 올려 놓은 복사본이 된다. 아직 master 가 그대로 남아 있으므로 이부분을 해결해 보자.

```ruby
      c0

      ^
      |

      c1
      ^
      |
  ----|
  ^
  |
  c2
 master*
  ^
  |
  c3'
 bugFix
```

일단 마스터 브랜치를 선택하고 bugFix 브랜치쪽으로 리베이스 해보자. `git rebase bugFix`

```ruby
      c0

      ^
      |

      c1
      ^
      |
  ----|
  ^
  |
  c2
  ^
  |
  c3'
 master*
 bugFix

```

master 가 bugFix의 부모쪽에 있었기 때문에, 단순히 그 브랜치를 더 최신의 커밋을 가리키게 이동하는것이 전부.


### Reset

Git 에는 작업한 것을 되돌리는 여러가지 방법이 있습니다. 변경 내역을 되돌리는 것도 커밋과 마찬가지로 낮은 수준의 일(개별 파일이나 묶음을 스테이징 하는 것)과 높은 수준의 일(실제 변경이 복구되는 방법)이 있는데요, 여기서는 후자에 집중해 알려드릴게요.

git 에서 변경한 내용을 되돌리는 방법은 크게 두가지가 있습니다 -- 하나는 `git reset` 을 쓰는 거고, 다른 하나는 `git revert` 를 사용하는것입니다.

`git reset` 은 브랜치로 하여금 예전의 커밋을 가리키도록 이동시키는 방식으로 변경 내용을 되돌립니다. 이런 관점에서 "히스토리를 고쳐쓴다"라고 말할 수 있습니다. 즉, `git reset` 은 마치 애초에 커밋하지 않은 것처럼 예전 커밋으로 브랜치를 옮기는 것입니다.


```ruby
      c0

      ^
      |

      c1
      ^
      |
      |
      c2 <-- master*

```

`git reset HEAD~1`


```ruby
      c0

      ^
      |

      c1 <-- master*

```

그림에서처럼 master 브랜치가 가리키던 커밋을 c1 으로 다시 옮겼음. 이러면 로컬 레파지토리에는 마치 c2 커밋이 아예 없었던것과 마찬가지 상태가 된다.

### Revert

각자의 컴퓨터에서 작업하는 로컬 브랜치의 경우 reset 을 잘 쓸 수 있지만, "히스토리를 고쳐쓴다"는 점 때문에 다른 사람이 작업하는 리모트 브랜치에는 쓸 수 없음.

변경분을 되돌리고, 이 되돌린 내용을 다른 사람들과 공유하기 위해서는, `git revert` 를 써야한다.


```ruby
      c0

      ^
      |

      c1
      ^
      |
      |
      c2 <-- master*

```

`git revert HEAD`


```ruby
      c0

      ^
      |

      c1
      ^
      |
      |
      c2
      ^
      |
      |
      c2' <-- master*
```

어색하게도, 우리가 되돌리려고한 커밋의 아래에 새로운 커밋이 생겼음. c2 라는 새로운 커밋에 변경 내용이 기록되는데, 이 변경 내역이 정확히 c1 커밋 내용의 반대되는 내용이다. revert를 하면 다른 사람들에게도 변경 내역을 밀어(push) 보낼 수 있음.


